%% superordinate classfication
% the OVERALL GOAL of this program is to convert a 'neural response' from
% ANN (in the form of a time series) and outputs a 'class' that represents
% a superordinate level category
function distMat = main()

%% Specify the Path information (user needs to do this!)
PATH.PROJECT = '/Users/Qihong/Dropbox/github/categorization_PDP/';
% PATH.DATA_FOLDER = 'sim21.5_lessHidden';
PATH.DATA_FOLDER = 'sim16_large';
% provide the NAMEs of the data files (user need to set them mannually)
FILENAME.DATA = 'hiddenAll_e3.txt';
FILENAME.PROTOTYPE = 'PROTO.xlsx';

%% load the data and the prototype
[output, param] = loadData(PATH, FILENAME);

%% data preprocessing
% get activation matrices
activationMatrix = getActivationMatrices(output, param);
numTimePoints = size(activationMatrix,1);
% get labels
[~, Y] = getLabels(param);

%% loop over all categories
numCategories = size(Y,2);
distMat = cell(numTimePoints,numCategories);
% loop over all time points
for j = 1 : numCategories
    %% Run MDS for all time points
    for i = 1 : numTimePoints
        distMat{i,j} = squareform(pdist(activationMatrix{i}, 'euclidean'));
    end
end

% plot mds over time

% set up selection matrix for superordinate distance and basic distance
select = getSelectionMatrices(param);

% analyze basic level distance and superordinate level distance over time
size(distMat{1,1});
j = 1; % category 1 - 3
i = 5; % time points 1 - 25 


curMat = distMat{i,j}
avgDist.sup = curMat(select.sup)
avgDist.ba

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% Helper functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% compute the direct sum of the N identical matrices
function output = iterDsum(matrix, iteration)
output = matrix;
% compute the direct sum
while iteration > 1
    iteration = iteration - 1;
    output = dsum(output, matrix);
end
end

%% set up selection matrix for superordinate distance and basic distance
function select = getSelectionMatrices(param)

% get superordinate selection matrix
temp = true(param.numInstances,param.numInstances);
select.sup = ~iterDsum(temp,param.numCategory.sup);

% get basic level selection matrix
temp = true(param.numCategory.bas,param.numCategory.bas);
temp = iterDsum(temp,(param.numCategory.bas*param.numCategory.sup));
select.bas = (~logical(temp + select.sup)); 

% get the subordinate level selection matrix
select.sub = ~logical(select.bas + select.sup + eye(param.numStimuli));
end
